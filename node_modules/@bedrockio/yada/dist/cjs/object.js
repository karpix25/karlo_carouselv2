"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _TypeSchema = _interopRequireDefault(require("./TypeSchema"));
var _errors = require("./errors");
var _utils = require("./utils");
var _Schema = _interopRequireWildcard(require("./Schema"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const BASE_ASSERTIONS = ['type', 'transform', 'field'];

/**
 * @typedef {{ [key: string]: Schema } | {}} SchemaMap
 */

class ObjectSchema extends _TypeSchema.default {
  constructor(fields, meta) {
    super(Object, {
      ...meta,
      fields,
      message: 'Object failed validation.'
    });
    this.setup();
  }

  /**
   * @private
   */
  setup() {
    this.assert('type', val => {
      if (val === null || typeof val !== 'object') {
        throw new _errors.LocalizedError('Must be an object.');
      }
    });
    this.transform((obj, options) => {
      const {
        fields,
        stripUnknown,
        expandDotSyntax
      } = options;
      if (obj) {
        const result = {};
        if (expandDotSyntax) {
          obj = expandDotProperties(obj);
        }
        for (let key of Object.keys(obj)) {
          if (!fields || key in fields) {
            result[key] = obj[key];
          } else if (!stripUnknown) {
            throw new _errors.LocalizedError('Unknown field "{key}".', {
              key,
              type: 'field'
            });
          }
        }
        return result;
      }
    });
    for (let [key, schema] of Object.entries(this.getFields())) {
      if (!(0, _Schema.isSchema)(schema)) {
        throw new Error(`Key "${key}" must be a schema`);
      }
      this.assert('field', async (obj, options) => {
        if (obj) {
          const {
            path = []
          } = options;
          const {
            strip
          } = schema.meta;
          const val = obj[key];
          options = {
            ...options,
            path: [...path, key]
          };
          if (strip && strip(val, options)) {
            delete obj[key];
            return;
          }
          try {
            // Do not pass down message into validators
            // to allow custom messages to take precedence.
            options = (0, _utils.omit)(options, 'message');
            const result = await schema.validate(val, options);
            if (result !== undefined) {
              return {
                ...obj,
                [key]: result
              };
            }
          } catch (error) {
            throw new _errors.FieldError('Field failed validation.', key, error.original, error.details);
          }
        }
      });
    }
  }

  /**
   * @private
   */
  getFields() {
    return this.meta.fields || {};
  }

  /**
   * @param {SchemaMap|Schema} arg Object or schema to append.
   */
  // @ts-ignore
  append(arg) {
    let schema;
    if (arg instanceof ObjectSchema) {
      schema = arg;
    } else if (arg instanceof _Schema.default) {
      // If the schema is of a different type then
      // simply append it and don't merge fields.
      return super.append(arg);
    } else {
      schema = new ObjectSchema(arg);
    }
    const fields = {
      ...this.meta.fields,
      ...schema.meta.fields
    };
    const merged = new ObjectSchema(fields, {
      ...this.meta,
      ...schema.meta
    });
    const assertions = [...this.assertions, ...schema.assertions];
    for (let assertion of assertions) {
      const {
        type
      } = assertion;
      if (!BASE_ASSERTIONS.includes(type)) {
        merged.pushAssertion(assertion);
      }
    }
    return merged;
  }

  /**
   * @param {...string} [names] Names to include.
   */
  pick(...names) {
    if (Array.isArray(names[0])) {
      names = names[0];
    }
    const fields = (0, _utils.pick)(this.meta.fields, names);
    return new ObjectSchema(fields, {
      ...this.meta
    });
  }

  /**
   * @param {...string} [names] Names to exclude.
   */
  omit(...names) {
    if (Array.isArray(names[0])) {
      names = names[0];
    }
    const fields = (0, _utils.omit)(this.meta.fields, names);
    return new ObjectSchema(fields, {
      ...this.meta
    });
  }
  toOpenApi(extra) {
    const properties = {};
    for (let [key, schema] of Object.entries(this.getFields())) {
      properties[key] = schema.toOpenApi(extra);
    }
    return {
      ...super.toOpenApi(extra),
      ...(Object.keys(properties).length > 0 && {
        properties
      })
    };
  }
}
function expandDotProperties(obj) {
  const result = {};
  for (let [key, val] of Object.entries(obj || {})) {
    const split = key.split('.');
    if (split.length > 1) {
      let node = result;
      for (let i = 0; i < split.length; i++) {
        const token = split[i];
        if (i === split.length - 1) {
          node[token] = val;
        } else {
          node[token] = {};
        }
        node = node[token];
      }
    } else {
      result[key] = val;
    }
  }
  return result;
}

/**
 * Creates an [object schema](https://github.com/bedrockio/yada#object).
 *
 * @param {SchemaMap} [map] An map of keys to schemas.
 * If not passed any object shape will be allowed. If an
 * empty object is passed then no keys will be allowed.
 */
function _default(map) {
  return new ObjectSchema(map);
}