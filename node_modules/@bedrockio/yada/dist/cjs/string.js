"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var _validator = _interopRequireDefault(require("validator"));
var _TypeSchema = _interopRequireDefault(require("./TypeSchema"));
var _errors = require("./errors");
var _password = require("./password");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const SLUG_REG = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;
const PHONE_REG = /^\+\d{1,3}\d{3,14}$/;
const PHONE_DESCRIPTION = 'A phone number in [E.164](https://en.wikipedia.org/wiki/E.164) format.';
class StringSchema extends _TypeSchema.default {
  constructor() {
    super(String);
    this.assert('type', (val, options) => {
      const {
        cast,
        allowEmpty
      } = options;
      if (cast && typeof val !== 'string') {
        val = String(val);
      }
      if (typeof val !== 'string') {
        throw new _errors.LocalizedError('Must be a string.');
      } else if (!allowEmpty && val === '') {
        throw new _errors.LocalizedError('String may not be empty.');
      }
      return val;
    });
  }

  /**
   * @returns {this}
   */
  required() {
    return this.clone({
      required: true
    }).assert('required', val => {
      if (val == null) {
        throw new _errors.LocalizedError('Value is required.');
      }
    });
  }

  /**
   * @returns {this}
   */
  allowEmpty() {
    return this.options({
      allowEmpty: true
    });
  }

  /**
   * @param {number} length
   */
  length(length) {
    return this.clone({
      length
    }).assert('length', str => {
      if (str && str.length !== length) {
        throw new _errors.LocalizedError('Must be exactly {length} characters.', {
          length
        });
      }
    });
  }

  /**
   * @param {number} length
   */
  min(length) {
    return this.clone({
      min: length
    }).assert('length', str => {
      if (str && str.length < length) {
        throw new _errors.LocalizedError('Must be {length} characters or more.', {
          length
        });
      }
    });
  }

  /**
   * @param {number} length
   */
  max(length) {
    return this.clone({
      max: length
    }).assert('length', str => {
      if (str && str.length > length) {
        throw new _errors.LocalizedError('Must be {length} characters or less.', {
          length
        });
      }
    });
  }
  trim() {
    return this.clone().transform(str => {
      return str.trim();
    });
  }

  /**
   * @param {boolean} [assert] Throws an error if not lowercase. Default: `false`.
   */
  lowercase(assert = false) {
    return this.clone().transform(str => {
      const lower = str.toLowerCase();
      if (lower !== str) {
        if (assert) {
          throw new _errors.LocalizedError('Must be in lower case.');
        }
        return lower;
      }
    });
  }

  /**
   * @param {boolean} [assert] Throws an error if not uppercase. Default: `false`.
   */
  uppercase(assert = false) {
    return this.clone().transform(str => {
      const upper = str.toUpperCase();
      if (upper !== str) {
        if (assert) {
          throw new _errors.LocalizedError('Must be in upper case.');
        }
        return upper;
      }
    });
  }

  /**
   * @param {RegExp} reg
   */
  match(reg) {
    if (!(reg instanceof RegExp)) {
      throw new _errors.LocalizedError('Argument must be a regular expression');
    }
    return this.clone().assert('regex', str => {
      if (str && !reg.test(str)) {
        throw new _errors.LocalizedError('Must match pattern {reg}.', {
          reg
        });
      }
    });
  }
  email() {
    return this.format('email', str => {
      if (!_validator.default.isEmail(str)) {
        throw new _errors.LocalizedError('Must be an email address.');
      }
    });
  }
  phone() {
    return this.format('phone', str => {
      if (!PHONE_REG.test(str)) {
        throw new _errors.LocalizedError('Must be a valid phone number.');
      }
    }).description(PHONE_DESCRIPTION);
  }
  hex() {
    return this.format('hex', str => {
      if (!_validator.default.isHexadecimal(str)) {
        throw new _errors.LocalizedError('Must be hexadecimal.');
      }
    });
  }
  md5() {
    return this.format('md5', str => {
      if (!_validator.default.isHash(str, 'md5')) {
        throw new _errors.LocalizedError('Must be a hash in md5 format.');
      }
    });
  }
  sha1() {
    return this.format('sha1', str => {
      if (!_validator.default.isHash(str, 'sha1')) {
        throw new _errors.LocalizedError('Must be a hash in sha1 format.');
      }
    });
  }
  ascii() {
    return this.format('ascii', str => {
      if (!_validator.default.isAscii(str)) {
        throw new _errors.LocalizedError('Must be ASCII.');
      }
    });
  }

  /**
   * @param {object} [options]
   * @param {boolean} [options.urlSafe]
   */
  base64(options) {
    return this.format('base64', str => {
      if (!_validator.default.isBase64(str, options)) {
        throw new _errors.LocalizedError('Must be base64.');
      }
    });
  }
  creditCard() {
    return this.format('credit-card', str => {
      if (!_validator.default.isCreditCard(str)) {
        throw new _errors.LocalizedError('Must be a valid credit card number.');
      }
    });
  }
  ip() {
    return this.format('ip', str => {
      if (!_validator.default.isIP(str)) {
        throw new _errors.LocalizedError('Must be a valid IP address.');
      }
    });
  }
  country() {
    return this.format('country', str => {
      if (!_validator.default.isISO31661Alpha2(str)) {
        throw new _errors.LocalizedError('Must be a valid country code.');
      }
    });
  }
  locale() {
    return this.format('locale', str => {
      if (!_validator.default.isLocale(str)) {
        throw new _errors.LocalizedError('Must be a valid locale code.');
      }
    });
  }
  jwt() {
    return this.format('jwt', str => {
      if (!_validator.default.isJWT(str)) {
        throw new _errors.LocalizedError('Must be a valid JWT token.');
      }
    });
  }
  slug() {
    return this.format('slug', str => {
      // Validator shows some issues here so use a custom regex.
      if (!SLUG_REG.test(str)) {
        throw new _errors.LocalizedError('Must be a valid slug.');
      }
    });
  }
  latlng() {
    return this.format('latlng', str => {
      if (!_validator.default.isLatLong(str)) {
        throw new _errors.LocalizedError('Must be a valid lat,lng coordinate.');
      }
    });
  }

  /**
   * @param {string} locale
   */
  postalCode(locale = 'any') {
    return this.format('postal-code', str => {
      if (!_validator.default.isPostalCode(str, locale)) {
        throw new _errors.LocalizedError('Must be a valid postal code.');
      }
    });
  }
  zipcode() {
    return this.format('zipcode', str => {
      if (!_validator.default.isPostalCode(str, 'US')) {
        throw new _errors.LocalizedError('Must be a valid zipcode.');
      }
    });
  }

  /**
   * @param {object} [options]
   * @param {number} [options.minLength]
   * @param {number} [options.minNumbers]
   * @param {number} [options.minSymbols]
   * @param {number} [options.minLowercase]
   * @param {number} [options.minUppercase]
   */
  password(options = {}) {
    const {
      description,
      minLength,
      minNumbers,
      minSymbols,
      minLowercase,
      minUppercase
    } = (0, _password.getPasswordOptions)(options);
    const schema = this.clone().description(description);
    if (minLength) {
      schema.assert('password', (0, _password.validateLength)(minLength));
    }
    if (minLowercase) {
      schema.assert('password', (0, _password.validateLowercase)(minLowercase));
    }
    if (minUppercase) {
      schema.assert('password', (0, _password.validateUppercase)(minUppercase));
    }
    if (minNumbers) {
      schema.assert('password', (0, _password.validateNumbers)(minNumbers));
    }
    if (minSymbols) {
      schema.assert('password', (0, _password.validateSymbols)(minSymbols));
    }
    return schema;
  }

  /**
   * @param {object} [options]
   * @param {boolean} [options.require_protocol]
   * @param {boolean} [options.require_valid_protocol]
   * @param {boolean} [options.require_host]
   * @param {boolean} [options.require_port]
   * @param {boolean} [options.allow_protocol_relative_urls]
   * @param {boolean} [options.allow_fragments]
   * @param {boolean} [options.allow_query_components]
   * @param {boolean} [options.validate_length]
   * @param {string[]} [options.protocols]
   */
  url(options) {
    return this.format('url', str => {
      if (!_validator.default.isURL(str, options)) {
        throw new _errors.LocalizedError('Must be a valid URL.');
      }
    });
  }

  /**
   * @param {object} [options]
   * @param {boolean} [options.require_tld=true]
   * @param {boolean} [options.allow_underscores=false]
   * @param {boolean} [options.allow_trailing_dot=false]
   * @param {boolean} [options.allow_numeric_tld=false]
   * @param {boolean} [options.allow_wildcard=false]
   * @param {boolean} [options.ignore_max_length=false]
   */
  domain(options) {
    return this.format('domain', str => {
      if (!_validator.default.isFQDN(str, options)) {
        throw new _errors.LocalizedError('Must be a valid domain.');
      }
    });
  }

  /**
   * @param {1 | 2 | 3 | 4 | 5} [version] Version of UUID to check.
   */
  uuid(version) {
    return this.format('uuid', str => {
      if (!_validator.default.isUUID(str, version)) {
        throw new _errors.LocalizedError('Must be a valid unique id.');
      }
    });
  }
  btc() {
    return this.format('bitcoin-address', str => {
      if (!_validator.default.isBtcAddress(str)) {
        throw new _errors.LocalizedError('Must be a valid Bitcoin address.');
      }
    });
  }
  eth() {
    return this.format('etherium-address', str => {
      if (!_validator.default.isEthereumAddress(str)) {
        throw new _errors.LocalizedError('Must be a valid Ethereum address.');
      }
    });
  }
  swift() {
    return this.format('swift-code', str => {
      if (!_validator.default.isBIC(str)) {
        throw new _errors.LocalizedError('Must be a valid SWIFT code.');
      }
    });
  }
  mongo() {
    return this.format('mongo-object-id', str => {
      if (!_validator.default.isMongoId(str)) {
        throw new _errors.LocalizedError('Must be a valid ObjectId.');
      }
    });
  }
  toOpenApi(extra) {
    const {
      min,
      max
    } = this.meta;
    return {
      ...super.toOpenApi(extra),
      ...(min != null && {
        minLength: min
      }),
      ...(max != null && {
        maxLength: max
      })
    };
  }
}

/**
 * Creates a [string schema](https://github.com/bedrockio/yada#string).
 */
function _default() {
  return new StringSchema();
}