"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = middleware;
var _bytes = _interopRequireDefault(require("bytes"));
var _logger = require("./logger");
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const IGNORE_UA_REG = /^(GoogleHC|kube-probe)/;

/**
 * @param {Object} [options]
 * @param {RegExp[]|string[]} [options.ignoreUserAgents] An array of
 * strings or regexes to test against.
 */
function middleware(options) {
  return (ctx, next) => {
    if (isAllowedRequest(ctx, options)) {
      const start = new Date();
      ctx.res.once('finish', () => {
        (0, _logger.formatRequest)({
          ...getRequestInfo(ctx),
          // @ts-ignore
          latency: new Date() - start
        });
      });
    }
    return next();
  };
}
function isAllowedRequest(ctx, options = {}) {
  const {
    ignoreUserAgents = [IGNORE_UA_REG]
  } = options;
  const ua = ctx.request.headers['user-agent'] || '';
  return ignoreUserAgents.some(test => {
    return !ua.match(test);
  });
}
function getRequestInfo(ctx) {
  const {
    headers
  } = ctx.request;
  const level = ctx.status < 500 ? 'info' : 'error';
  const requestLength = ctx.request.headers['content-length'];
  const responseLength = ctx.response.headers['content-length'];
  const size = (0, _bytes.default)(Number(responseLength || 0));
  const userId = ctx.state?.authUser?.id;
  const referer = headers['referer'];
  const userAgent = headers['user-agent'];
  const protocol = headers['x-forwarded-proto'] || ctx.protocol;
  const remoteIp = headers['x-forwarded-for'];
  const serverIp = ctx.ip;
  return {
    level,
    userId,
    url: ctx.href,
    path: ctx.url,
    method: ctx.method,
    status: ctx.status,
    requestLength,
    responseLength,
    referer,
    remoteIp,
    serverIp,
    protocol,
    userAgent,
    headers,
    size
  };
}
module.exports = exports.default;