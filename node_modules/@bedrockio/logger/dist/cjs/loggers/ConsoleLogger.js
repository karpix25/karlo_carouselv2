"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _kleur = require("kleur");
var _BaseLogger = _interopRequireDefault(require("./BaseLogger"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const LOG_LEVELS = ['debug', 'info', 'warn', 'error'];
class ConsoleLogger extends _BaseLogger.default {
  debug(...args) {
    return this.emit('debug', ...args);
  }
  info(...args) {
    return this.emit('info', ...args);
  }
  warn(...args) {
    return this.emit('warn', ...args);
  }
  error(...args) {
    return this.emit('error', ...args);
  }
  emit(level, ...args) {
    if (LOG_LEVELS.indexOf(level) >= getMinLevel()) {
      this.print(level, ...args);
    }
  }
  print(level, ...args) {
    const fn = console[level];
    let msg = '';
    if (typeof args[0] === 'string') {
      const [first, ...rest] = args;
      msg += this.formatForLevel(level, first);
      args = rest;
    }
    fn(msg, ...args);
  }
  formatRequest(request) {
    let {
      method,
      path,
      status,
      latency,
      size
    } = request;
    const level = status < 500 ? 'info' : 'error';
    method = method.padEnd(6, ' ');
    status = this.formatStatus(status);
    const meta = this.formatMeta(`${path} ${latency}ms ${size}`);
    const msg = `${method} ${status} ${meta}`;
    this[level](msg);
  }
  formatStatus(status) {
    return status;
  }
  formatMeta(meta) {
    return meta;
  }
  formatForLevel(level, msg) {
    if (level === 'error') {
      return (0, _kleur.red)(msg);
    } else if (level === 'warn') {
      return (0, _kleur.yellow)(msg);
    } else {
      return (0, _kleur.gray)(msg);
    }
  }
}
exports.default = ConsoleLogger;
function getMinLevel() {
  const minLevel = LOG_LEVELS.indexOf(process.env.LOG_LEVEL || 'info');
  if (minLevel === -1) {
    throw new Error(`Invalid log level. Must be one of ${LOG_LEVELS}`);
  }
  return minLevel;
}
module.exports = exports.default;